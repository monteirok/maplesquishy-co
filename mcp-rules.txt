// =============================================
// shop-loyalty-mcp-scaffold
// TypeScript + Express + Drizzle (PostgreSQL) + Stripe
// Minimal MCP-style server exposing tools/resources/events
// Compatible with a Next.js App Router client via server actions
// =============================================
//
// File layout (single-file export; copy into repo as multiple files):
// - package.json
// - tsconfig.json
// - drizzle.config.ts
// - .env.example
// - src/db/schema.ts
// - src/db/client.ts
// - src/policies/points.ts
// - src/mcp/types.ts
// - src/mcp/registry.ts
// - src/mcp/server.ts
// - src/routes/auth.ts (session extraction helpers)
// - src/routes/webhooks/stripe.ts
// - src/index.ts (bootstrap)
// - README.md (quickstart)
//
// ------------------------------------------------------------
// --- filepath: package.json
// ------------------------------------------------------------
{
  "name": "shop-loyalty-mcp-scaffold",
  "version": "1.0.0",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "tsx watch src/index.ts",
    "build": "tsc -p tsconfig.json",
    "start": "node dist/index.js",
    "drizzle:generate": "drizzle-kit generate --out ./drizzle",
    "drizzle:migrate": "drizzle-kit migrate --out ./drizzle",
    "drizzle:push": "drizzle-kit push"
  },
  "dependencies": {
    "express": "^4.19.2",
    "zod": "^3.23.8",
    "stripe": "^16.12.0",
    "pg": "^8.11.3",
    "drizzle-orm": "^0.33.0",
    "dotenv": "^16.4.5",
    "cookie": "^0.6.0",
    "uuid": "^9.0.1",
    "pino": "^9.3.2"
  },
  "devDependencies": {
    "@types/express": "^4.17.21",
    "@types/node": "^22.5.1",
    "drizzle-kit": "^0.26.0",
    "tsx": "^4.19.1",
    "typescript": "^5.5.4"
  }
}

// ------------------------------------------------------------
// --- filepath: tsconfig.json
// ------------------------------------------------------------
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "outDir": "dist",
    "rootDir": "src",
    "strict": true,
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "forceConsistentCasingInFileNames": true,
    "skipLibCheck": true
  },
  "include": ["src"]
}

// ------------------------------------------------------------
// --- filepath: drizzle.config.ts
// ------------------------------------------------------------
import type { Config } from "drizzle-kit";
export default {
  schema: "./src/db/schema.ts",
  out: "./drizzle",
  driver: "pg",
  dbCredentials: {
    connectionString: process.env.DATABASE_URL ?? "postgres://user:pass@localhost:5432/shoployalty"
  }
} satisfies Config;

// ------------------------------------------------------------
// --- filepath: .env.example
// ------------------------------------------------------------
# Server
PORT=4000
NODE_ENV=development
APP_BASE_URL=http://localhost:4000
CORS_ORIGIN=http://localhost:3000

# Database
DATABASE_URL=postgres://postgres:postgres@localhost:5432/shoployalty

# Stripe
STRIPE_SECRET_KEY=sk_test_...
STRIPE_WEBHOOK_SECRET=whsec_...

# Session/JWT (if you validate NextAuth JWTs here)
NEXTAUTH_SECRET=super-secret-string

# Policy
POINTS_RATE_BASIS_POINTS=1000 # 10% -> 1000 bps

// ------------------------------------------------------------
// --- filepath: src/db/schema.ts
// ------------------------------------------------------------
import { pgTable, serial, integer, text, timestamp, varchar, boolean, numeric } from "drizzle-orm/pg-core";
import { sql } from "drizzle-orm";

export const users = pgTable("users", {
  id: varchar("id", { length: 36 }).primaryKey(),
  email: varchar("email", { length: 255 }).notNull().unique(),
  createdAt: timestamp("created_at", { withTimezone: true }).defaultNow().notNull()
});

export const orders = pgTable("orders", {
  id: varchar("id", { length: 36 }).primaryKey(),
  userId: varchar("user_id", { length: 36 }).notNull().references(() => users.id),
  totalCents: integer("total_cents").notNull(),
  currency: varchar("currency", { length: 10 }).notNull(),
  taxCents: integer("tax_cents").notNull().default(0),
  shippingCents: integer("shipping_cents").notNull().default(0),
  discountCents: integer("discount_cents").notNull().default(0),
  createdAt: timestamp("created_at", { withTimezone: true }).defaultNow().notNull()
});

export const pointsLedger = pgTable("points_ledger", {
  id: serial("id").primaryKey(),
  userId: varchar("user_id", { length: 36 }).notNull().references(() => users.id),
  delta: integer("delta").notNull(), // positive for earn, negative for redeem/refund clawback
  reason: varchar("reason", { length: 32 }).notNull(), // order_credit | reward_redeem | admin_adjust | refund_clawback
  ref: varchar("ref", { length: 64 }),
  createdAt: timestamp("created_at", { withTimezone: true }).defaultNow().notNull()
});

export const rewards = pgTable("rewards", {
  id: varchar("id", { length: 36 }).primaryKey(),
  name: varchar("name", { length: 128 }).notNull(),
  costPoints: integer("cost_points").notNull(),
  sku: varchar("sku", { length: 64 }),
  active: boolean("active").notNull().default(true)
});

export const pointsBalanceView = sql`CREATE OR REPLACE VIEW points_balance AS\n  SELECT user_id, COALESCE(SUM(delta), 0) AS balance\n  FROM points_ledger\n  GROUP BY user_id;`;

// ------------------------------------------------------------
// --- filepath: src/db/client.ts
// ------------------------------------------------------------
import { drizzle } from "drizzle-orm/node-postgres";
import pkg from "pg";
import * as schema from "./schema.js";

const { Pool } = pkg;

export const pool = new Pool({ connectionString: process.env.DATABASE_URL });
export const db = drizzle(pool, { schema });

export async function withTransaction<T>(fn: Parameters<typeof db.transaction>[0]) {
  return db.transaction(fn);
}

// ------------------------------------------------------------
// --- filepath: src/policies/points.ts
// ------------------------------------------------------------
export function computeEarnedPoints(opts: {
  totalCents: number;
  taxCents: number;
  shippingCents: number;
  discountCents: number;
  basisPoints?: number; // default 1000 (10%)
}): number {
  const bps = opts.basisPoints ?? Number(process.env.POINTS_RATE_BASIS_POINTS ?? 1000);
  const eligibleCents = Math.max(0, opts.totalCents - opts.taxCents - opts.shippingCents - opts.discountCents);
  const raw = (eligibleCents * bps) / 10_000;
  return Math.floor(raw); // floor to integer points
}

// ------------------------------------------------------------
// --- filepath: src/mcp/types.ts
// ------------------------------------------------------------
import { z } from "zod";

export type ToolHandler = (ctx: Ctx, input: unknown) => Promise<unknown>;

export type Ctx = {
  userId: string | null; // null for service tools (e.g., webhooks)
  logger: import("pino").Logger;
};

export const VoidSchema = z.object({}).strict();

export const PaginatedSchema = z.object({
  page: z.number().int().min(1).default(1),
  pageSize: z.number().int().min(1).max(100).default(20)
}).strict();

export const CheckoutCreateInput = z.object({
  items: z.array(z.object({ sku: z.string(), qty: z.number().int().min(1) })),
  successUrl: z.string().url(),
  cancelUrl: z.string().url()
}).strict();

export const RewardsListInput = z.object({ availableOnly: z.boolean().default(true) }).strict();

export const RewardsRedeemInput = z.object({ rewardId: z.string() }).strict();

export const StripeWebhookInput = z.object({ signature: z.string(), payload: z.string() }).strict();

// ------------------------------------------------------------
// --- filepath: src/mcp/registry.ts
// ------------------------------------------------------------
import type { ToolHandler, Ctx } from "./types.js";
import { z } from "zod";
import { CheckoutCreateInput, RewardsListInput, RewardsRedeemInput, PaginatedSchema } from "./types.js";
import Stripe from "stripe";
import { db } from "../db/client.js";
import { rewards as rewardsTable, pointsLedger, orders } from "../db/schema.js";
import { eq, desc, sql } from "drizzle-orm";
import { computeEarnedPoints } from "../policies/points.js";
import { v4 as uuidv4 } from "uuid";

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, { apiVersion: "2024-06-20" });

export const tools: Record<string, { schema: z.ZodTypeAny; handler: ToolHandler; auth: "user" | "public" }> = {
  // --- shop.checkout.create ---
  "shop.checkout.create": {
    schema: CheckoutCreateInput,
    auth: "user",
    handler: async (ctx, input) => {
      const { items, successUrl, cancelUrl } = CheckoutCreateInput.parse(input);
      if (!ctx.userId) throw new Error("Unauthenticated");
      // In a real app, resolve SKUs to Stripe prices
      const lineItems = items.map((it) => ({ price: it.sku, quantity: it.qty }));
      const session = await stripe.checkout.sessions.create({
        mode: "payment",
        line_items: lineItems,
        success_url: successUrl,
        cancel_url: cancelUrl,
        metadata: { userId: ctx.userId }
      });
      return { id: session.id, url: session.url };
    }
  },

  // --- orders.list ---
  "orders.list": {
    schema: PaginatedSchema,
    auth: "user",
    handler: async (ctx, input) => {
      const { page, pageSize } = PaginatedSchema.parse(input);
      if (!ctx.userId) throw new Error("Unauthenticated");
      const offset = (page - 1) * pageSize;
      const rows = await db
        .select()
        .from(orders)
        .where(eq(orders.userId, ctx.userId))
        .orderBy(desc(orders.createdAt))
        .limit(pageSize)
        .offset(offset);
      return rows;
    }
  },

  // --- points.balance.get ---
  "points.balance.get": {
    schema: z.object({}).strict(),
    auth: "user",
    handler: async (ctx) => {
      if (!ctx.userId) throw new Error("Unauthenticated");
      const [row] = await db.execute(sql`SELECT COALESCE(SUM(delta), 0) AS balance FROM points_ledger WHERE user_id = ${ctx.userId}`);
      return { balance: Number((row as any)?.balance ?? 0) };
    }
  },

  // --- rewards.list ---
  "rewards.list": {
    schema: RewardsListInput,
    auth: "user",
    handler: async (ctx, input) => {
      RewardsListInput.parse(input);
      const list = await db.select().from(rewardsTable).where(eq(rewardsTable.active, true));
      return list;
    }
  },

  // --- rewards.redeem ---
  "rewards.redeem": {
    schema: RewardsRedeemInput,
    auth: "user",
    handler: async (ctx, input) => {
      const { rewardId } = RewardsRedeemInput.parse(input);
      if (!ctx.userId) throw new Error("Unauthenticated");
      const [reward] = await db.select().from(rewardsTable).where(eq(rewardsTable.id, rewardId));
      if (!reward || !reward.active) throw new Error("Reward not found or inactive");

      // SERIALIZABLE transaction to prevent race
      return db.transaction(async (tx) => {
        const [balRow] = await tx.execute(sql`SELECT COALESCE(SUM(delta), 0) as balance FROM points_ledger WHERE user_id = ${ctx.userId} FOR UPDATE`);
        const balance = Number((balRow as any)?.balance ?? 0);
        if (balance < reward.costPoints) throw new Error("Insufficient points");
        await tx.insert(pointsLedger).values({ userId: ctx.userId!, delta: -reward.costPoints, reason: "reward_redeem", ref: reward.id });
        return { ok: true };
      });
    }
  },
};

export async function handleStripeCheckoutCompleted(evt: Stripe.CheckoutSessionCompletedEvent, logger: import("pino").Logger) {
  const s = evt.data.object;
  const userId = (s.metadata as any)?.userId as string | undefined;
  if (!userId) {
    logger.warn({ session: s.id }, "No userId on session metadata; skipping points credit");
    return;
  }
  // Derive order financials from Stripe session
  const totalCents = (s.amount_total ?? 0);
  const currency = s.currency?.toUpperCase() ?? "USD";
  const taxCents = s.total_details?.amount_tax ?? 0;
  const shippingCents = s.total_details?.amount_shipping ?? 0;
  const discountCents = s.total_details?.amount_discount ?? 0;

  const orderId = uuidv4();
  await db.transaction(async (tx) => {
    await tx.insert(orders).values({ id: orderId, userId, totalCents, currency, taxCents, shippingCents, discountCents });
    const earned = computeEarnedPoints({ totalCents, taxCents, shippingCents, discountCents });
    if (earned > 0) {
      await tx.insert(pointsLedger).values({ userId, delta: earned, reason: "order_credit", ref: orderId });
    }
  });
}

// ------------------------------------------------------------
// --- filepath: src/mcp/server.ts
// ------------------------------------------------------------
import express from "express";
import type { Request, Response, NextFunction } from "express";
import pino from "pino";
import { tools } from "./registry.js";
import type { Ctx } from "./types.js";
import { z } from "zod";

const logger = pino({ level: process.env.NODE_ENV === "production" ? "info" : "debug" });

// Simple session extractor: expect X-User-Id header from trusted Next.js server actions
function getUserId(req: Request): string | null {
  // In production, validate a NextAuth JWT or session cookie with your session store.
  const h = req.header("x-user-id");
  return h ? String(h) : null;
}

export function createMcpApp() {
  const app = express();
  app.use(express.json({ limit: "1mb" }));

  // CORS for Next.js local dev
  app.use((req, res, next) => {
    const origin = process.env.CORS_ORIGIN ?? "http://localhost:3000";
    res.header("Access-Control-Allow-Origin", origin);
    res.header("Access-Control-Allow-Headers", "Content-Type, X-User-Id");
    res.header("Access-Control-Allow-Methods", "POST, GET, OPTIONS");
    if (req.method === "OPTIONS") return res.sendStatus(204);
    next();
  });

  // Health
  app.get("/health", (_req, res) => res.json({ ok: true }));

  // Generic MCP Tools endpoint: POST /mcp/tools/:name
  app.post("/mcp/tools/:name", async (req: Request, res: Response) => {
    try {
      const name = req.params.name;
      const def = tools[name];
      if (!def) return res.status(404).json({ error: "tool_not_found" });

      let userId: string | null = null;
      if (def.auth === "user") {
        userId = getUserId(req);
        if (!userId) return res.status(401).json({ error: "unauthenticated" });
      }

      const ctx: Ctx = { userId, logger };
      const parsed = def.schema.parse(req.body ?? {});
      const out = await def.handler(ctx, parsed);
      res.json({ ok: true, result: out });
    } catch (err: any) {
      logger.error({ err }, "tool_error");
      if (err instanceof z.ZodError) {
        return res.status(400).json({ error: "invalid_input", details: err.flatten() });
      }
      res.status(500).json({ error: "internal_error" });
    }
  });

  return app;
}

// ------------------------------------------------------------
// --- filepath: src/routes/auth.ts
// ------------------------------------------------------------
// Placeholder helpers showing how you'd validate NextAuth on the server side.
// In production, replace with a JWT verification against NEXTAUTH_SECRET or call your Next.js app.
import type { Request } from "express";
export function requireUserId(req: Request): string {
  const id = req.header("x-user-id");
  if (!id) throw new Error("Unauthenticated");
  return String(id);
}

// ------------------------------------------------------------
// --- filepath: src/routes/webhooks/stripe.ts
// ------------------------------------------------------------
import express from "express";
import Stripe from "stripe";
import { handleStripeCheckoutCompleted } from "../../src/mcp/registry.js";
import pino from "pino";

export function stripeWebhookRouter() {
  const router = express.Router();
  const logger = pino({ name: "stripe-webhook" });
  const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, { apiVersion: "2024-06-20" });

  // Stripe requires raw body for signature verification
  router.post("/stripe", express.raw({ type: "application/json" }), async (req, res) => {
    try {
      const sig = req.headers["stripe-signature"] as string;
      const secret = process.env.STRIPE_WEBHOOK_SECRET!;
      const event = stripe.webhooks.constructEvent(req.body, sig, secret);

      if (event.type === "checkout.session.completed") {
        await handleStripeCheckoutCompleted(event as any, logger);
      }

      res.json({ received: true });
    } catch (err: any) {
      logger.error({ err }, "stripe_webhook_error");
      res.status(400).send(`Webhook Error: ${err.message}`);
    }
  });

  return router;
}

// ------------------------------------------------------------
// --- filepath: src/index.ts
// ------------------------------------------------------------
import express from "express";
import { createMcpApp } from "./mcp/server.js";
import { stripeWebhookRouter } from "./routes/webhooks/stripe.js";
import dotenv from "dotenv";

dotenv.config();

const app = express();

// Stripe webhook must be mounted before any body parsers that consume JSON
app.use("/webhooks", stripeWebhookRouter());

// Mount MCP app (which includes its own JSON parser and CORS)
app.use(createMcpApp());

const port = Number(process.env.PORT ?? 4000);
app.listen(port, () => {
  // eslint-disable-next-line no-console
  console.log(`MCP server running on http://localhost:${port}`);
});

// ------------------------------------------------------------
// --- filepath: README.md
// ------------------------------------------------------------
# Shop Loyalty MCP Server (TypeScript + Drizzle + Stripe)

A minimal MCP-style tool server for a Next.js storefront that issues points worth **10%** of eligible order subtotal and supports reward redemption.

## Features
- **MCP Tools**: `shop.checkout.create`, `orders.list`, `points.balance.get`, `rewards.list`, `rewards.redeem`
- **Stripe**: Checkout Session + verified webhook â†’ credits points and records orders
- **Drizzle ORM (Postgres)**: Users, Orders, Points Ledger, Rewards
- **Security**: User-scoped tool calls via trusted header (`X-User-Id`) for local dev; replace with NextAuth JWT validation in prod

## Quickstart

1. **Clone & install**
```bash
pnpm i # or npm i / yarn
cp .env.example .env
```

2. **Database**
```bash
createdb shoployalty # or use Docker Postgres
pnpm drizzle:generate && pnpm drizzle:push
```

3. **Run**
```bash
pnpm dev
```

4. **Test health**
```bash
curl http://localhost:4000/health
```

## Calling tools from Next.js (server actions)

```ts
// app/actions/checkout.ts
"use server";
export async function createCheckout(items: { sku: string; qty: number }[]) {
  const res = await fetch(`${process.env.MCP_URL}/mcp/tools/shop.checkout.create`, {
    method: "POST",
    headers: {
      "content-type": "application/json",
      "x-user-id": /* your NextAuth session user id */ "USER_ID"
    },
    body: JSON.stringify({
      items,
      successUrl: `${process.env.NEXT_PUBLIC_URL}/account?ok=1`,
      cancelUrl: `${process.env.NEXT_PUBLIC_URL}/cart`
    })
  });
  if (!res.ok) throw new Error("checkout_failed");
  const json = await res.json();
  return json.result as { id: string; url: string };
}
```

## Stripe webhook URL
Set your endpoint to:
```
POST ${APP_BASE_URL}/webhooks/stripe
```

## Security notes
- Replace the `X-User-Id` contract with real **NextAuth** verification (e.g., verify JWT using `NEXTAUTH_SECRET` or query your session DB).
- Keep Stripe webhook secret safe; endpoint uses **raw body**.
- All point mutations go through the **ledger**; balances are `SUM(delta)`.
- Reward redemption runs in a transaction with row lock to avoid race conditions.

## Points policy
- Earned points = floor(eligible_subtotal * 10%). Eligible subtotal = total - tax - shipping - discount.
- Refunds should add a negative ledger entry (implement in a `charge.refunded` handler similarly to checkout completed).

## Migrations
Use `drizzle-kit` to generate and push migrations after editing `schema.ts`.

---
// END OF SCAFFOLD
